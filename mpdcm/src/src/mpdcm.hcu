/*aponteeduardo@gmail.com */
/* copyright 2014 */

# ifndef DDM_HEADER
# define DDM_HEADER

# ifdef __CUDACC__

# include "math.h"
# include "curand_kernel.h"
# include "curand.h"
# include <stdio.h>

# define HANDLE_ERROR( err ) {if (err != cudaSuccess ) { \
        printf( "%s in %s at line %d\n", cudaGetErrorString( err ), \
                __FILE__, __LINE__ ); \
        exit( EXIT_FAILURE ); \
    }}

# define HANDLE_NULL( a ) {if (a == NULL) { \
                            printf( "Host memory failed in %s at line %d\n", \
                                    __FILE__, __LINE__ ); \
                            exit( EXIT_FAILURE );}}

# endif

# ifdef __CUDACC__
# define BDDM_EXTERN extern "C"
# else
# define BDDM_EXTERN
# endif

# define MPDOUBLEFLAG 

// Determines whether compile double or single precision

# ifdef MPDOUBLEFLAG
# define MPFLOAT double 
# else
# define MPFLOAT float
# endif

typedef enum { MF_TRUE, MF_FALSE } MatFlag;

typedef struct
{
    int dim;
    MPFLOAT *arr;
} dbuff;

/*  Degrees of freedom */
typedef struct
{
    int dim_x;
    int dim_u;

    /* This flag indicates whether the matrix should be used or not. */

    MatFlag fA;
    MatFlag fB;
    MatFlag fC;

    MPFLOAT *A;
    MPFLOAT *B;
    MPFLOAT *C;

    MPFLOAT *K; /* Kappa */
    MPFLOAT *tau;

    MPFLOAT V0;
    MPFLOAT E0;
    MPFLOAT ln1_E0; /* For optimization. */
    MPFLOAT lnE0; /* For optimization. */
    MPFLOAT k1;
    MPFLOAT k2;
    MPFLOAT k3;

    MPFLOAT alpha;
    MPFLOAT gamma;

} ThetaDCM;

/* Fixed values */
typedef struct
{
    MPFLOAT dt; /* Step size in the integration */
    MPFLOAT dyu; /* Ratio of the sampling rate of y and u. */
    MPFLOAT de; /* Precomputed h */
    char mode; /* Either 'f' or 'c'. It's the type of array of the theta, i.e.
        fortran or c. */
} PThetaDCM;


/* Type def for the integrators. */
typedef int (*integrator)(MPFLOAT *, MPFLOAT *, MPFLOAT *, void *, MPFLOAT *,
            void *, MPFLOAT *, int, int, int, int, int, int);

/* Kernel launchers */

typedef void (*klauncher)(MPFLOAT *, MPFLOAT *, MPFLOAT *, void *, MPFLOAT *, 
    void *, MPFLOAT *, int, int, int, int, int, int, unsigned int*);

/* Update of x */

typedef void (*fupx)(dbuff, dbuff, dbuff, void *, void *, dbuff);

typedef struct {
    MPFLOAT *x;
    MPFLOAT *y;
    MPFLOAT *u;
    void *p_theta;
    MPFLOAT *d_theta;
    void *p_ptheta;
    MPFLOAT *d_ptheta;
    int nx;
    int ny;
    int nu;
    int dp;
    int nt;
    int nb;
    unsigned int * errcode;
    } kernpars;

// Thread info. Needed for the synchronization of the adapted step methods.
typedef struct {
    unsigned int ns; // Number of data sets
    unsigned int cs; // Current data set.
} thr_info;

BDDM_EXTERN
int mpdcm_fmri_euler( MPFLOAT *x, MPFLOAT *y, MPFLOAT *u, 
    void *theta, MPFLOAT *d_theta, void *ptheta, MPFLOAT *d_ptheta, 
    int nx, int ny, int nu, int dp, int nt, int nb);
    /* 
    Integrate DCM using a parallel architecture with the euler method.

    x -- States. Will not be used explicitely.
    y -- Observables. Output will be stored here.
    u -- Input. Input to the process.
    theta -- Parameters
    d_theta -- Data of the parameters of variable size
    ptheta -- Priors and fixed values
    d_ptheta -- Data of the prior of variable size
    nx -- Dimensions of x
    nu -- Dimensions of u
    ny -- Dimensions of y
    dp -- Number of data points
    nt -- Size of theta second dimension
    nb -- Size of theta first dimension 
    */

BDDM_EXTERN
int mpdcm_fmri_kr4( MPFLOAT *x, MPFLOAT *y, MPFLOAT *u, 
    void *theta, MPFLOAT *d_theta, void *ptheta, MPFLOAT *d_ptheta, 
    int nx, int ny, int nu, int dp, int nt, int nb);
    /* 
    Integrate DCM using a parallel architecture, with a kutta runga of 4th 
    order. 

    x -- States. Will not be used explicitely.
    y -- Observables. Output will be stored here.
    u -- Input. Input to the process.
    theta -- Parameters
    d_theta -- Data of the parameters of variable size
    ptheta -- Priors and fixed values
    d_ptheta -- Data of the prior of variable size
    nx -- Dimensions of x
    nu -- Dimensions of u
    ny -- Dimensions of y
    dp -- Number of data points
    nt -- Size of theta second dimension
    nb -- Size of theta first dimension 
    */

BDDM_EXTERN
int mpdcm_fmri_bs( MPFLOAT *x, MPFLOAT *y, MPFLOAT *u, 
    void *theta, MPFLOAT *d_theta, void *ptheta, MPFLOAT *d_ptheta, 
    int nx, int ny, int nu, int dp, int nt, int nb);
    /* 
    Integrate DCM using a parallel architecture, with a kutta runga of 4th 
    order. 

    x -- States. Will not be used explicitely.
    y -- Observables. Output will be stored here.
    u -- Input. Input to the process.
    theta -- Parameters
    d_theta -- Data of the parameters of variable size
    ptheta -- Priors and fixed values
    d_ptheta -- Data of the prior of variable size
    nx -- Dimensions of x
    nu -- Dimensions of u
    ny -- Dimensions of y
    dp -- Number of data points
    nt -- Size of theta second dimension
    nb -- Size of theta first dimension 
    */



#define DIM_X 5 

# ifdef __CUDACC__

// Constants for the integrators


#define DIM_PTHETA 3
#define DIM_DPTHETA 0

#define INDEX_X 0
#define INDEX_F 1
#define INDEX_S 2
#define INDEX_V 3
#define INDEX_Q 4

#define PRELOC_SIZE_X_KR4 3
#define PRELOC_SIZE_X_EULER 2
#define PRELOC_SIZE_X_BS 5

#define DIM_THETA 7

#define INDEX_V0 0
#define INDEX_E0 1
#define INDEX_K1 2
#define INDEX_K2 3
#define INDEX_K3 4
#define INDEX_ALPHA 5
#define INDEX_GAMMA 6

#define INDEX_LK1 0 
#define INDEX_LK2 1 
#define INDEX_LK3 2 

#define NUM_BLOCKS 6
#define NUM_THREADS 32

#define KRW1 0.16666666666
#define KRW2 0.33333333333
#define KRW3 0.33333333333
#define KRW4 0.16666666666

#define BSA1 0.5
#define BSA2 0.075

#define BSB1 0.2222222222222222
#define BSB2 0.3333333333333333
#define BSB3 0.4444444444444444

#define BSZ1 (-0.069444444444444)
#define BSZ2 0.083333333333333
#define BSZ3 0.111111111111111
#define BSZ4 (-0.125)

// Constat for the variable step model.

#define MINDY 1
#define MAXDY 64

#define MINTOL 0.000001
#define MAXTOL 0.001000


# endif

// end cuda defines

# endif
